
= モノイド(Monoid)
ifndef::stem[:stem: latexmath]
ifndef::imagesdir[:imagesdir: ./img/]
ifndef::source-highlighter[:source-highlighter: highlightjs]

ifndef::highlightjs-theme:[:highlightjs-theme: solarized-dark]

++++
<style type="text/css">
p>code {background-color: #aaaaaa};

th,td {
    border: solid 0px;  
}　
td>code {background-color: #aaaaaa};
} 
</style>
++++

モノイドは、理解するのが簡単、しかし奥が深く、モナドと同じかそれ以上に関数型プログラミングで応用局面もあり実用性が高いという、費用対効果（コスパ）抜群の品質の高いプログラミングの部品となりうるものです。

だいたい、モナドを知りたいのなら、同時にモノイドを知っておくべきなのは当たり前のことなのですが、ここまでモナド偏重でモノイドについてはあまり語られないのは、<<ch_01.adoc#whysohard>>の事情が原因です。

== 単位元

また、小学１年算数を復習すると、

[stem]
++++
1 + 1
++++

みたいな足し算を最初に学びます。

子供というか、我々大人でも、脳は、すでに馴染みがある事象の延長・拡張でしか「理解する」というのは無理で、まず最初は、具体的な物質である「数え棒」「おはじき」を渡されて、徐々に数学的な抽象的概念に慣らされていきます。

どういう数学なのかというと、**（正の）自然数全体のなす加法の二項演算**ですよね。一番シンプルなパターンです。

このとき、 `+` は、**（正の）自然数全体** と組（ペア）となる**二項演算**としてしっかりと定義されています。

児童が**（正の）自然数全体のなす加法の二項演算**という抽象的作業に慣らされたところで大事件が起こります。


---

https://ja.wikibooks.org/wiki/%E5%B0%8F%E5%AD%A6%E6%A0%A1%E7%AE%97%E6%95%B0/1%E5%AD%A6%E5%B9%B4#%E3%82%BC%E3%83%AD_0[**ゼロ 0**]

_1 から 1 を ひいた かず を ゼロ と いいます。 ゼロ は 0 と かきます。_

_0は、なにも、ない　かず です。_

_だから、 かず に 0 を たしても、 かわりません。_

_たとえば_

_7+0=7_
_「なな たす ゼロ は（わ） なな」です。_

---

[stem]
++++
7 + 0 = 7
++++


ゼロの発明は、数学史の飛躍の一つで、5世紀ごろのインド文明
で数字としてのゼロが発明されたのも数学が生まれてから2000年くらい経過した後ですし、ヨーロッパで広まったのは、中世を経てルネサンスのさらに後のニュートンの時代ですから、人類の数学史を考えると結構最近の発明だと言えます。

それなのに、さらっと小１の児童にゼロの概念をさも当たり前のように伝えるのですから、教育というものの凄まじさを実感できます。

数の体系が

**（正の）自然数全体** 

↓

**（ゼロを含む）自然数全体** 

にしれっと拡張されてしまいました。

そして、ここで誤魔化されてはならないのが、同じ記号　`+` であっても、ゲームのルールが異なる、ということ。

**二項演算**というのは、必ず、演算対象と組（ペア）となってはじめて意味がある定義が成されるはずだったので、

**（正の）自然数全体のなす加法の二項演算**

↓

**（ゼロを含む）自然数全体のなす加法の二項演算**

と、二項演算も同時に更新されてしまいました。


[TIP]
.単位元の添加
====
こういう正の自然数に更に「ゼロの後乗せ」してゼロを含む自然数に拡張する、同時に組（ペア）になっているはずの二項演算子も更新することを、単位元の添加と言います。 

https://ja.wikipedia.org/wiki/%E5%8D%98%E4%BD%8D%E5%85%83#%E6%80%A7%E8%B3%AA[単位元#性質]

_マグマ (M, ∗) が与えられたとき、M に M のどの元とも異なる新たな元 1 を付け加えた集合 M1 := M ∪ {1} で_

_任意の a ∈ M1 に対して a * 1 = 1 * a = a_
_と定めて、M の演算 ∗ を M1 上に延長することにより、元 1 を M1 の ∗ に関する単位元とすることができる。この (M1, ∗) を (M, ∗) の 1-添加という。_

_もし、M がもともと ∗ に関する単位元 e を持っていたとしても、e は M1 上ではもはや ∗ に関する単位元ではない。_




====



こういう、「だから、 かず に 0 を たしても、 かわりません。」というような、ある対象を演算しても不変になるような対象を
https://ja.wikipedia.org/wiki/%E5%8D%98%E4%BD%8D%E5%85%83[
単位元]と言います。

ここで「かず」とは書かずに「対象」とか書いたのは、演算も単位元も、べつに数に限らないからです。

---

> 数学、とくに抽象代数学において、単位元（たんいげん, 英: identity element）あるいは中立元（ちゅうりつげん, 英: neutral element）は、二項演算を備えた集合の特別な元で、ほかのどの元もその二項演算による単位元との結合の影響を受けない。

https://ja.wikipedia.org/wiki/%E5%8D%98%E4%BD%8D%E5%85%83[
単位元]

---

[WARNING]
.単位元を表す記号
====
「単位元」は、**identity element**から、

- identity
- e

あるいは「中立元」**neutral element**の頭文字**n**に似ている（と筆者は思っている）

- η　（エータ、イータ、イタ）

と表記されることが多いですが、本稿では、とっつきやすさを重視して、

**e**と表記することにします。

ただし、後々まったく同じ数学的対象なのに、後から、単位元のことを、identityと書かれたり、ηと書かれたり、場合によっては `unit` だの　`return`　だの本質ではないところの用語の使い回しで、モナド界隈特有の混乱を極めるので、それは心の準備が必要です。
====


=== 左右の単位元


加法の単位元 `e` は `0` で、
[stem]
++++
0 + 7 = 7 = 7 + 0 
++++

乗法の単位元 `e` は `1` で、
[stem]
++++
1 \times 7 = 7 = 7 \times 1
++++

文字列の単位元 `e` は `""`  となります。
[stem]
++++
"" + "Hello" = "Hello" = "Hello" + "" 
++++

=== 結合法則

[stem]
++++
(a + b) + c = a + (b + c)
++++
　
[stem]
++++
(a \times b) \times c = a \times (b \times c)
++++

[stem]
++++
("Hello" + "\space") + "world" = "Hello" + ("\space" + "world")
++++

このように

1. **左右の単位元 e がある**

2. **結合法則が成り立つ** 

代数構造のことを、モノイド(monoid)と呼びます。

ちなみに、四則演算の仲間でも引き算と割り算は、モノイドにはなりません、念の為。

== なぜモノイドと結合法則が重要なのか？

モノイド(monoid)だの「結合法則」だの言われると、理屈は単純でも、仰々しい天下り説明ぽくて、なんでそんなことが必要なのか？と思いがちなので説明します。

モノイドは、構造として対称性があって、適当に組み合わせても不変性があるので、関数型プログラミングの部品としては優れています。

部品の組み合わせということで、たとえばLEGOブロックを考えてみると、組み立て順序は自由なはずです。ある部分を先に組み立てて、別の部分を組み立て、それらをまた組み合わせる。これがもし、aとbは先に組み立てなければいけない、bとcを先に組み立てたものに後からaを組み合わせても、別物になるから！となると面倒なことになります。

USBデバイスを考えてみましょう。USBハブやら組み合わせ自由で、その接続する順番は気にする必要はないですよね？組み合わせは組み合わせです。順序によって構造に違いは生まれません。

ちなみに、LEGOブロックの組み立て、USBデバイスの接続も二項演算です。小１の授業でやられたみたいに、何も組み立てない、何も接続しない、というゲームのルールを追加したならば、二項演算しても何も影響を及ばなさい単位元の添加したってことなので、それまで考えていた組み立ての意味とは異なるでしょうが、そういうモノイドになります。


**結合法則が成り立つ** というのは、法則によってプログラマが縛られたり、法則を満たすように留意事項増える、ということではありません。まったくその逆で、法則によって、こういった組み合わせ順序は自由、という自由度、柔軟性、堅牢性がある部品、という保証があるということです。言い換えると、使いやすい基準をパスしている品質の高い部品だということ。

プログラミングはただでさえ、複雑で、何も考えないでやると、どんどん複雑になっていってコントロール不能、デバッグ不可能になっていきますよね？なるだけ構造はシンプルに維持しておきたいのです。

この部品はモノイドなので、組み合わせの自由度が高い、逆に、モノイドじゃないので、どんどん構造が増えていって面倒なことになるな・・・という認識が持てるのと持てないとでは大きな違いです。**この部品はモノイドであることは事前に十分確認済みなので、このメソッド（二項演算）まわりで予期しない振る舞いをして、バグが出るはずはない、と確信を持ってスルーできるのはかなり大きいメリットですよね？**



　

[TIP]
.モノイドは３つ組
====

> マグマ（英語: magma）または亜群（あぐん、groupoid）は、演算によって定義される種類の基本的な代数的構造であり、集合 M とその上の二項演算 M * M → M からなる組をいう。

> 値と演算は常に組（ペア）で存在するのであって、演算子の単独では意味を成しません。

でしたが、マグマ(M,∗)でも特に、

1. **左右の単位元 e がある**

2. **結合法則が成り立つ** 

がモノイドです。モノイドのことは、

[stem]
++++
(M,e,*) 
++++

と書くことにしましょう。

組（ペア）から３つ組（トリプル）になったのがポイントです。

具体的な二項演算が定まったときは、

[stem]
++++
(自然数,0, +) 
++++

[stem]
++++
(自然数,1,\times) 
++++

[stem]
++++
(文字列,"", +) 
++++

というようになります。
====

 

== 単一のタイプで自己完結

モノイドは

[stem]
++++
自然数 + 自然数 = 自然数
++++

[stem]
++++
自然数 \times 自然数 = 自然数
++++

[stem]
++++
文字列 + 文字列 = 文字列
++++

[stem]
++++
レゴブロック + レゴブロック = レゴブロック
++++

[stem]
++++
USBデバイス + USBデバイス = USBデバイス
++++


というようにすべて、ただ一種類のタイプで自己完結している二項演算の世界です。

モノイドは連続的に接続可能で、自然数の加法の二項演算の場合、

[stem]
++++
1 + 2 + 3 = 6
++++

という二項演算の連続的操作は、そのまま、

[stem]
++++
(1).plus(2).plus(3) = 6
++++

と<<ch_06.adoc#withobjectmethod>>、メソッドチェーンとして表現できます。

== Array（リスト・配列）は、モノイド

Array（リスト・配列）は、モノイドです。

[stem]
++++
(Array,[\space],concat) 
++++


=== Array.concat メソッドという二項演算
[stem]
++++
[1,2].concat([3]).concat([4,5]) = [1,2,3,4,5]
++++

.https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/concat[Array.concat]

> concat() メソッドは、配列に他の配列や値をつないでできた新しい配列を返します。

=== Array.concat メソッドで不変の左右の単位元 eとは？

[stem]
++++
[\space].concat([1,2])
++++
[stem]
++++
= [1,2]
++++
[stem]
++++
=[1,2].concat([\space]) 
++++

`Array.concat` メソッドを二項演算 `*` と再び捉え直すと、

[stem]
++++
[\space]*[1,2] = [1,2] = [1,2]*[\space]
++++

と、Arrayモノイドの左右の単位元 e は `[ ]` 。




=== Array.concat は結合法則を満たす

[stem]
++++
[1,2] * [3] * [4,5] = [1,2,3,4,5] = [1,2] * ( [3] * [4,5] )
++++


[source,js]
.Array Monoid
----
const array1 =
    [1, 2]
        .concat([3]) <1>
        .concat([4, 5]); <2>

console.log(array1);
----

<1> `[1, 2]` と `[3]` を接続

<2> `[1, 2, 3]`　と `[4,5]` を接続

[source,js]
.Console
----
[ 1, 2, 3, 4, 5 ]
----


[source,js]
.Array Monoid 結合法則
----
const array1 =
    [1, 2].concat(　<1>
        [3].concat([4, 5]) <2>
    );

console.log(array1);
----

<1> `[1,2]` と `[3,4,5]` を後から接続

<2> `[3]` と `[4,5]` を先に接続

[source,js]
.Console
----
[ 1, 2, 3, 4, 5 ]
----

と結合順序を変えても結果は変わりません。


== まとめ

モノイドは関数型プログラミングで役立つし、理解しておくのは重要。この章はただの紹介にすぎず、もっと充実すべく加筆が必要。

[TIP]
.Array.flatMapと似ている？
====

モノイドの結合法則から、`Array.concat` のメソッドチェーンを組み替えてネストしても同じ結果を出す、という光景は、モナドである `Array.flatMap` のメソッドチェーンの組み換えとネストの実現ととても似ています。

次の章ではそこを追求してスッキリさせましょう。

====



