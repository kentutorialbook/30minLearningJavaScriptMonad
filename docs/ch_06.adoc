
[[relation]]
= 代数学と関数型プログラミングとオブジェクト指向の用語・記法の相互関係
ifndef::stem[:stem: latexmath]
ifndef::imagesdir[:imagesdir: ./img/]

++++
<style type="text/css">
p>code {background-color: #aaaaaa};

th,td {
    border: solid 0px;  
}　
td>code {background-color: #aaaaaa};
} 
</style>
++++

この章では、今まで棚上げしてきた、モヤモヤしていたものをスッキリさせることを目指します。

[QUOTE]
====
関数型プログラミングは、プログラミングの複雑性を、以下の２つ

- 値
- 値でもある関数

の組み合わせ（function composition）で制御します。

---

メソッドチェーンをもって書き連ねるだけで、Demo:こんなことができるようになる

---

jQueryは値(オブジェクト)＆関数（オブジェクトにぶらさがるメソッド群）のペアです。
====

なとど書いていますが、これは若干問題があります。多数の意味が曖昧な言葉、定義がはっきりしない、その正体についてはJavaScriptや関数型プログラミングとオブジェクト指向プログラミングで出て来がちな複数の文脈で暗黙の了解に委ねられている用語が散見されます。

- 値
- 関数
- オブジェクト
- メソッド

オブジェクト・メソッドについては明らかに出自がオブジェクト指向の用語です。

値、関数については、関数型ぽいが、同時にオブジェクト指向でも使われたりする。

JavaScriptは良かれ悪しかれ「マルチパラダイムプログラミング」言語なので、こういうわけのわからない状況に至ってもまあ仕方はないですが、特に関数型プログラミングを導入する際に曖昧さと混乱を引きずったままでゴリ押ししてしまうことが多いです。

用語は違うのに、数学的対象としては同じものを指し示していたりすることで、概念の重複、冗長性、曖昧さが生じてしまっています。

== 二項演算とは　小学１/２年の算数からの復習

そこでとりあえず、根底となるプロトコルである数学の記法についてまず整理しておきましょう。

数学と言ってもたいしたことはない、小学１/２年の算数レベルのお話です。

[stem]
++++
1 + 2 = 3
++++

[stem]
++++
1 \times 2 = 2
++++

これは初等数学で真っ先に習う
https://ja.wikipedia.org/wiki/%E7%AE%97%E8%A1%93#%E5%9B%9B%E5%89%87%E6%BC%94%E7%AE%97[四則演算]のうち「加算」と「乗算」です。

またさらに一般化、抽象化して、「2つの数から新たな数を決定する演算」のことを https://ja.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E6%BC%94%E7%AE%97[二項演算]と呼びます。要するに**演算のパラメータが２つあったらそれは二項演算**。また、２つのパラメータの中間に `+` 、`-` などの演算子を置くのを https://ja.wikipedia.org/wiki/%E4%B8%AD%E7%BD%AE%E8%A8%98%E6%B3%95[中置記法]と呼びます。

パラメータが１個ならば、 https://ja.wikipedia.org/wiki/%E5%8D%98%E9%A0%85%E6%BC%94%E7%AE%97[単項演算] で、中学で習う平方根の演算子、ルートを使って 

[stem]
++++
\sqrt9 = 3
++++

となりますね。

== 演算は関数として捉えられる

パラメータの文字が出た時点でお察しですが、以上の演算は関数として解釈できます。

単項演算は、パラメータが１個なので、

[source,js]
.Math.sqrt
----
Math.sqrt(9) //3
----

二項演算は、パラメータが2個なので、

[source,js]
.plus
----
const plus = (a) => (b) => (a + b);

plus(1)(2) //3
----

[[withobjectmethod]]
== オブジェクト指向のメソッドでは

ここであえて復習するつもりもありませんが、オブジェクト指向のメソッドとは、オブジェクトに紐付いた関数のことですね。

JavaScriptの数値はカッコ（）で囲んでやると、 https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Number[Numberオブジェクト]になるので、`Number.prototype` へ新たに `plus` メソッドを追加します。


[[NumberPlus]]
[source,js]
.Number(a).plus(b)
----
Object.defineProperty(
    Number.prototype,
    "plus", {
        value: function (b) {
            return this + b;
        }
    });
----


[source,js]
.(1).plus(2) === 3
----
(1).plus(2) //3
----

- オブジェクト自身の値 `this = 1` 
- メソッド `plus` 関数
- パラメータ `2`

二項演算（中置記法）

[stem]
++++
1 + 2
++++

は、JavaScriptのオブジェクトとメソッドで書けます。

[stem]
++++
(1).plus(2) 
++++

そして、このように、値(オブジェクト)＆関数（オブジェクトにぶらさがるメソッド）のペアで書くのは非常に優れているんですね。

jQueryのメソッドチェーンのことを思い出しましょう。


[stem]
++++
1 + 2 + 5 + 9
++++

は、そのまま、

[stem]
++++
(1).plus(2).plus(5).plus(9) 
++++

と、メソッドチェーンで自然に書けてしまう。

[TIP]
====
逆に言うと、メソッドチェーンは、代数のなんらかの二項演算の連鎖をコード上に表現しているにすぎません。そして後からでてきますが、これはendofunctorやモナドにも当てはまります。
====

オブジェクトにぶらさがるメソッドではない普通の関数の形式

[stem]　
++++
plus(1)(2)
++++
ではこううまくは行きません。

[stem]　
++++
plus(plus(plus(1)(2))(5))(9)
++++

「なんとか地獄」と名前がつきそうな感じです。

JavaScriptがマルチパラダイムで、オブジェクト指向のメソッド形式で書けるおかげで、**任意の二項演算、つまりパラメータを２つとる関数は、特別な定義不要で、その関数名（メソッド名）のまま中置記法が実現できてしまう**という予期しない副産物（棚ぼた）です。

== 値と演算は常に組（ペア）で存在する

> 抽象代数学におけるマグマ（英語: magma）または亜群（あぐん、groupoid）は、演算によって定義される種類の基本的な代数的構造であり、**集合 M とその上の二項演算 M × M → M からなる組をいう**。マグマ M における二項演算は M において閉じていることは要求するが、それ以外の何らの公理も課すものではない。
https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%B0%E3%83%9E_(%E6%95%B0%E5%AD%A6)[マグマ(数学)]

基本的な代数構造において、演算だけ独立して存在していることはありません。必ず演算のターゲットとなる値の集合と組（ペア）として存在しています。

たとえば、 四則演算のうち「加算」は演算対象となるデータとは加算可能な数値ですよね？文字列であったり、なにかの画像データではありません。

_抽象代数学_ とか _代数的構造_ とか言われると、つい数値のことを連想しがちなのですが、

> マグマ M における二項演算は M において閉じていることは要求するが、それ以外の何らの公理も課すものではない。

とあるとおり、なんの制約もありません。

値が文字列ならば、その組となる、文字列というデータを演算するための二項演算は自由に定義可能だし、実際JavaScriptには、 https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String[String]プロトタイプオブジェクトと、それ専用の二項演算子が実装されています。


[source,js]
.Hello world
----
"Hello" + " " + "world"  //Hello world
----

文字列データを二項演算するときの `+` は文字列の接続処理で、数値データを二項演算する `+` の加算処理とは意味が異なります。**値と演算は常に組（ペア）で存在するのであって、演算子の単独では意味を成しません**。

そしてこれは、まさに**オブジェクトとメソッドの関係に合致**しており、二項演算の連続的操作が、そのまま上手くオブジェクトのメソッドチェーンで書けてしまう理論的背景が納得できます。

関数型プログラミングで、値、関数というとき、暗黙に組（ペア）となる相手がいます(プログラムで処理されないデータは意味がない)。そして、静的型付けの仕組み（JavaScriptならTypeScriptを使えばいい）などで、この値と関数の組（ペア）性を保証していきます。

しかし、繰り返し、これはまったく想定外のことですが、関数型プログラミングであっても、オブジェクト指向のオブジェクトとメソッドという組は、値（データ）と演算（関数）が組となる二項演算を定義する代数構造と解釈することで極めて有用です。

== まとめ

二項演算をベースに考える。


[NOTE]
====

マグマ（英語: magma）または亜群（あぐん、groupoid）は、演算によって定義される種類の基本的な代数的構造であり、集合 M とその上の二項演算 M * M → M からなる組をいう。

値と演算は常に組（ペア）で存在するのであって、演算子の単独では意味を成しません。

---

と、逐一書くのも面倒なので、今後マグマという組（ペア）は

[stem]
++++
(M, ∗) 
++++



と書くことにします。

演算 `*` はワイルドカードです。二項演算 M ∗ M → M  ならなんでも良い。

たとえば、二項演算が**自然数の足し算**と定まれば、ワイルドカード `*` は `+` になります。

[stem]
++++
(自然数,+) 
++++


二項演算が**自然数の掛け算**と定まれば、

[stem]
++++
(自然数,\times) 
++++

繰り返し念の為ですが、代数構造といえども、対象となるデータは、数値に限りません。

二項演算が**文字列の接続**と定まれば、ワイルドカード `*` は `+` になります。

[stem]
++++
(文字列,+) 
++++


====

マグマ(M, ∗) はプログラムの世界にそのまま展開できて、

`M` = 値、データ、オブジェクト

`*` = 二項演算、パラメータ２つの関数、メソッド

と言うように、データと処理の組、つまり**データ処理**のことだと解釈できます。

[stem]
++++
1 + 2 + 5 + 9
++++

という二項演算の連続的操作は、そのまま、

[stem]
++++
(1).plus(2).plus(5).plus(9) 
++++

とオブジェクトのメソッドチェーンとして表現できる。


.代数、関数型、オブジェクト指向のイディオム
[cols="h,d,d"]
|================
|代数          |値|演算
|関数型        |値、データ|関数
|オブジェクト指向|値、データ、オブジェクト|メソッド
|================
